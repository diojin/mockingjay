#                 Scala for the Impatient ###                   Cay S. Horstmann######                    Second printing, June 2013___##Contents---* [1. The Basics](#basics)  - [The apply Method](#the-apply-method)* [2. Control Structures and Functions](#control-structures-and-functions)  - [for loop](#for-loop)  - [for comprehension](#for-comprehension)  - [function](#function)    + [Default and Named Arguments](#default-and-named-arguments)    + [Variable Arguments](#variable-arguments)  - [procedure](#procedure)  - [Lazy Values](#lazy-values)  - [Exceptions](#exceptions)* [3. Working with Arrays](#working-with-arrays)  - [Range](#range)  - [for if yield or filter map](#for-if-yield-or-filter-map)  - [array sorting](#array-sorting)  - [multidimensional arrays](#multidimensional-arrays)  - [Interoperating with Java](#interoperating-with-java)* [4. Maps and Tuples](#maps-and-tuples)  - [pair](#pair)  - [Interoperating with Java for map](#interoperating-with-Java-for-map)  - [Tuples](#tuples)  - [Tuples to Map](#tuples-to-map)* [5. Classes](#classes)  - [Object-Private Fields](#object-private-fields)  - [auxiliary constructor](#auxiliary-constructor)  - [primary constructor](#primary-constructor)* [6. Objects](#objects)  - [Companion Objects](#companion-objects)  - [The apply Method](#the-apply-method-1)  - [Application Objects](#application-objects)  - [Enumerations](#enumerations)* [7. Packages and Imports](#packages-and-imports)  - [Scope Rules](#scope-rules)  - [Chained Package Clauses](#chained-package-clauses)  - [Top-of-File Notation](#top-of-file-notation)  - [Package Objects](#package-objects)  - [Renaming and Hiding Members](#renaming-and-hiding-members)* [8. Inheritance](#inheritance)  - [Type Checks and Casts](#type-checks-and-casts)  - [Overriding Fields](#overriding-fields)  - [Anonymous Subclasses](#anonymous-subclasses)  - [Abstract Fields](#abstract-fields)  - [The Scala Inheritance Hierarchy](#the-scala-inheritance-hierarchy)* [9. Files and Regular Expressions](#files-and-regular-expressions)  - [Process Control](#process-control)  - [Regular Expressions](#regular-expressions)* [10. Traits](#traits)  - [Objects with Traits](#objects-with-traits)  - [Fields in Traits](#fields-in-traits)  - [Trait Construction Order](#trait-construction-order)  - [linearization of the class](#linearization-of-the-class)  - [Initializing Trait Fields](#initializing-trait-fields)  - [Self Types](#self-types)* [Operators](#operators)Basics---Scala is statically typed, enabling the compiler to find errorsAs you can see, the Scala interpreter reads an expression, evaluates it, prints it, and reads the next expression. This is calledthe read-eval-print loop, or **REPL**.Technically speaking, the scala program is not an interpreter. Behind the scenes, your input is quickly compiled into bytecode,and the bytecode is executed by the Java virtual machine. For that reason, most Scala programmers prefer to call it “theREPL”.__Scala interpreter hotkeys:__  * tab completion for method, hit the Tab key * paste mode  If you want to paste a block of code into the REPL without worrying about its nearsightedness, use paste mode. Type  :paste  Then paste in the code block and type Ctrl+K. The REPL will then analyze the block in its entirety. Ctrl+D to finish the pasteA value declared with val is actually a constant—you can’t change its contents  To declare a variable whose contents can vary, use a var  Note that you need not specify the type of a value or variable. It is inferred from the type of the expression with which youinitialize it. (It is an error to declare a value or variable without initializing it.)  However, you can specify the type if necessary. For example,  ```scalaval greeting: String = nullval greeting: Any = "Hello"````In Scala, you use methods, not casts, to convert between numeric types. For example, 99.44.toInt is 99, and 99.toChar is 'c'.`  PS: 2 exceptions  1. way 1  ```scalaMessageFormat.format("the answer is {0} to {1}", "everything", 42.asInstanceOf[AnyRef]))  ```2. another possible example of type convert  ```scala    println(recursiveSum(1 to 10:_*))    println(recursiveSum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))    def recursiveSum(args: Int*):Int = {      if ( args.length == 0 ){        0      }else{        args(0) + recursiveSum(args.tail:_*)      }    }```Like Java, Scala has `7 numeric types: Byte, Char, Short, Int, Long, Float, and Double, and a Boolean type.` However, unlike Java, these types are classes. There is no distinction between primitive types and class types in Scala. You can invoke methods on numbers, for example:  ```scala1.to(10) // Yields Range(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)```Scala relies on the underlying java.lang.String class for strings. However, it augments that class with well over a hundred operations in the **StringOps** class.  ```scala"Hello".intersect("World") // Yields "lo"```In this expression, the java.lang.String object "Hello" is `implicitly converted to a StringOps object`, and then the intersect method of the **StringOps** class is applied.Similarly, there are classes **RichInt**, **RichDouble**, **RichChar**, and so on.Finally, there are classes **BigInt** and **BigDecimal** for computations with an arbitrary (but finite) number of digits. These are backed by the java.math.BigInteger and java.math.BigDecimal classes, but, as you will see in the next section, they are much more convenient because you `can use them with the usual mathematical operators.`  ```scalaval x: BigInt = 1234567890x * x * x // Yields 1881676371789154860897069000// That’s much better than Java, where you would have had to call x.multiply(x).multiply(x).```The + - * / % operators do their usual job, as do the bit operators & | ^ >> <<. There is just one surprising aspect: These operators are actually methods. For example,  `a + b`  is a shorthand for  `a.+(b)`  Here, + is the name of the method. Scala has no silly prejudice against non-alphanumeric characters in method names. You can define methods with just about any symbols for names.In general, you can write  `a method b`  as a shorthand for  `a.method(b)`  where method is a method with two parameters (one implicit, one explicit).There is one notable difference between Scala and Java or C++. `Scala does not have ++ or -- operators`. Instead, simply use +=1 or -=1:`Scala allows you to define operators`To use a package that starts with scala., you can omit the scala prefix. For example, import math._ is equivalent to import scala.math._, and math.sqrt(2) is the same as scala.math.sqrt(2).`Scala doesn’t have static methods`, but it has a similar feature, called __singleton objects__, which we will discuss in detail in Chapter 6. Often, a class has a __companion object__ whose methods act just like static methods do in Java. For example, the BigInt companion object to the BigInt class has a method probablePrime that generates a random prime number with a givennumber of bits:  ```scalaBigInt.probablePrime(100, scala.util.Random)```Note that the call BigInt.probablePrime is similar to a static method call in JavaHere, Random is a singleton random number generator object, defined in the scala.util package. This is one of the few situations where a singleton object is better than a class. In Java, it is a common error to construct a new java.util.Random object for each random number.Scala methods without parameters often don’t use parentheses. For example, the API of the StringOps class shows a method distinct, without (), to get the distinct letters in a string. You call it as   ```scala"Hello".distinct```The rule of thumb is that a parameterless method that doesn’t modify the object has no parentheses.#### The apply MethodIn Scala, it is common to use a syntax that looks like a function call. For example, if s is a string, then s(i) is the ith character of the string. (In C++, you would write s[i]; in Java, s.charAt(i).) Try it out in the REPL:  ```scala"Hello"(4) // Yields 'o'````You can think of this as an overloaded form of the () operator. It is implemented as a method with the name apply.`  For example, in the documentation of the StringOps class, you will find a method  ```scaladef apply(n: Int): Char```That is,   ```scala"Hello"(4)// is a shortcut for "Hello".apply(4) ```When you look at the documentation for the BigInt companion object, you will see apply methods that let you convert strings or numbers to BigInt objects.   For example,  ```scala// the call BigInt("1234567890") // is a shortcut for BigInt.apply("1234567890") ```It yields a new BigInt object, `without having to use new``Using the apply method of a companion object is a common Scala idiom for constructing objects.`  For example,  ```scalaArray(1, 4, 9, 16)```returns an array, thanks to the apply method of the Array companion object.`A method tagged as implicit is an automatic conversion.`  For example, the BigInt object has conversions from int and long to BigInt that are automatically called when needed. `Methods can have functions as parameters.`  For example, the count method in StringOps requires a function that returns true or false for a Char, specifying which characters should be counted:```scaladef count(p: (Char) => Boolean) : Int```You supply a function, often in a very compact notation, when you call the method. As an example, the call **s.count(_.isUpper)** counts the number of uppercase characters. Control Structures and Functions---You will encounter a fundamental difference between Scala and other programming languages. In Java or C++, we differentiate between expressions (such as 3 + 4) and statements (for example, an if statement).   `An expression has a value; a statement carries out an action. In Scala, almost all constructs have values.`  Here are the highlights of this chapter:  * `An if expression has a value`* `A block has a value—the value of its last expression`* The Scala for loop is like an “enhanced” Java for loop* Semicolons are (mostly) optional* `The void type is Unit`* Avoid using return in a function* Beware of missing = in a function definition* `Exceptions work just like in Java or C++, but you use a “pattern matching” syntax for catch`* `Scala has no checked exceptions`in Scala, an if/else has a value, namely the value of the expression that follows the if or else.  ```scalaval s = if (x > 0) 1 else -1```The Scala if/else combines the if/else and ?: constructs that are separate in Java and C++.The type of a mixed-type expression, such as  ```scalaif (x > 0) "positive" else -1```is the common supertype of both branches. In this example, one branch is a java.lang.String, and the other an Int. Their common supertype is called Any. If the else part is omitted, for example in  if(x>0) 1  then it is possible that the if statement yields no value. However, in Scala, every expression is supposed to have some value. `This is finessed by introducing a class Unit that has one value, written as ().` The if statement without an else is equivalent to  ```scalaif (x>0) 1 else ()````Think of () as a placeholder for “no useful value,” and think of Unit as the analog of void in Java or C++.`  Technically speaking, void has no value whereas Unit has one value that signifies “no value”. If you are so inclined, you can ponder the difference between an empty wallet and a wallet with a bill labeled “no dollars”.`Scala has no switch statement`, but it has a much more powerful pattern matching mechanismHowever, if you want to have more than one statement on a single line, you need to separate them with semicolons.In Scala, a { } block contains a sequence of expressions, and the result is also an expression. The value of the block is the value of the last expression.This feature can be useful if the initialization of a val takes more than one step. For example,  ```scalaval distance = { val dx = x - x0; val dy = y - y0; sqrt(dx * dx + dy * dy) }````In Scala, assignments have no value—or, strictly speaking, they have a value of type Unit.`A block that ends with an assignment statement, such as {r=r*n; n-=1} has a Unit value.You can read a line of input from the console with the `readLine` function. To read a numeric, Boolean, or character value, use readInt, readDouble, readByte, readShort, readLong, readFloat, readBoolean, or readChar. The readLine method, but not the other ones, takes a prompt string:  ```scalaval name = readLine("Your name: ")print("Your age: ")val age = readInt()printf("Hello, %s! Next year, you will be %d.\n", name, age + 1)```Notice: read*() methods are all deprecated after 2.11Scala has the same `while` and `do` loops as Java and C++. #### for loop```scalafor(i <- 1 to n)     r=r*i```The call 1 to n returns a Range of the numbers from 1 to n (inclusive).   The construct for **(i <- expr)** makes the variable i traverse all values of the expression to the right of the <-. Exactly how that traversal works depends on the type of the expression. For a Scala collection, such as a Range, the loop makes i assume each value in turn.  There is no val or var before the variable in the for loop. `The type of the variable is the element type of the collection`. The scope of the loop variable extends until the end of the loop.When traversing a string or array, you often need a range from 0 to n – 1. In that case, use the until method instead of the to method. It returns a range that doesn’t include the upper bound.```scalaval s = "Hello"var sum = 0for (i <- 0 until s.length) // Last value for i is s.length - 1  sum += s(i)```In this example, there is actually no need to use indexes. You can directly loop over the characters:  ```scalavar sum = 0for (ch <- "Hello")     sum += chprintln(sum)````In Scala, loops are not used as often as in other languages. As you will see in Chapter 12, you can often process the values in a sequence by applying a function to all of them, which can be done with a single method call.``Scala has no break or continue statements to break out of a loop`.   What to do if you need a break? Here are a few options:   1. Use a Boolean control variable instead.2. Use nested functions—you can return from the middle of a function.3. Use the break method in the Breaks object:```scalaimport scala.util.control.Breaks._breakable {  for (...) {    if (...) break; // Exits the breakable block ...   } }````Here, the control transfer is done by throwing and catching an exception, so you should avoid this mechanism when time is of the essence.`#### for comprehensionYou can have multiple generators of the form variable <- expression. Separate them by semicolons. For example,  ```scalafor (i <- 1 to 3; j <- 1 to 3) print((10 * i + j) + " ")// Prints 11 12 13 21 22 23 31 32 33```Each generator can have a guard, a Boolean condition preceded by if:  ```scalafor (i <- 1 to 3; j <- 1 to 3 if i != j) print((10 * i + j) + " ")// Prints 12 13 21 23 31 32```When the body of the for loop starts with yield, then the loop constructs a collection of values, one for each iteration: ```scalafor(i<-1 to 10) yield i%3    // Yields Vector(1, 2, 0, 1, 2, 0, 1, 2, 0, 1)```This type of loop is called a **for comprehension**.`The generated collection is compatible with the first generator.````scalafor (c <- "Hello"; i <- 0 to 1) yield (c + i).toChar     // Yields "HIeflmlmop"for (i <- 0 to 1; c <- "Hello") yield (c + i).toChar    // Yields Vector('H', 'e', 'l', 'l', 'o', 'I', 'f', 'm', 'm', 'p')```#### functionScala has functions in addition to methods. A method operates on an object, but a function doesn’t. C++ has functions as well, but in Java, you have to imitate them with static methods.  While there is nothing wrong with using return in a named function (except the waste of seven keystrokes), it is a good idea to get used to life without return. Pretty soon, you will be using lots of anonymous functions, and there, return doesn’t return a value to the caller. It breaks out to the enclosing named function. **Think of return as a kind of break statement for functions, and only use it when you want that breakout functionality.**You must specify the types of all parameters. However, as long as the function is not recursive, you need not specify the return type. The Scala compiler determines the return type from the type of the expression to the right of the = symbol.  ```scaladef fac(n: Int): Int = if (n <= 0) 1 else n * fac(n - 1)```##### Default and Named ArgumentsYou can provide default arguments for functions that are used when you don’t specify explicit values. For example,  ```scaladef decorate(str: String, left: String = "[", right: String = "]") =left + str + rightprintln(decorate("Hello"))```__Named arguments__  You can also specify the parameter names when you supply the arguments. For example,   ```scaladecorate(left = "<<<", str = "Hello", right = ">>>")// The result is "<<<Hello>>>".```##### Variable ArgumentsThe function receives a single parameter of type **Seq**  ```scaladef sum(args: Int*) = {  var result = 0  for (arg <- args) result += arg  result}println(sum(1, 4, 9, 16, 25))```__argument sequence__  ```scalaprintln( recursiveSum(1, 2, 3, 4, 5) )    println( recursiveSum(1 to 5:_*))def recursiveSum(args: Int*) : Int = {  if ( args.length== 0 )     0  else    args.head + recursiveSum(args.tail:_*)}```Here, the head of a sequence is its initial element, and tail is a sequence of all other elements. **That’s again a Seq, and we have to use : _* to convert it to an argument sequence.**  Generally, the : notation is used for **type ascription**, forcing the compiler to see a value as some particular type. This is not quite the same as casting._*,  It "splats" the sequence. This doesn't have a cutesy-name in the SLS, but here are the details. The important thing to get is that it changes how Scala binds the arguments to the method with repeated parameters. That's scala syntax for exploding subclasses of Seq[T].`When you call a Java method with variable (number of )arguments of type Object, such as PrintStream.printf or MessageFormat.format, you need to convert any primitive types by hand.` For example,```scalaval str = MessageFormat.format("The answer to {0} is {1}", "everything", 42.asInstanceOf[AnyRef])```This is the case for any Object parameter, but I mention it here because it is most common with **varargs** methods.#### procedureScala has a special notation for a function that returns no value. If the function body is enclosed in braces `without a preceding = symbol, then the return type is Unit.` Such a function is called a procedure. A procedure returns no value, and you only call it for its side effect.Some people (not me) dislike this concise syntax for procedures and suggest that you always use an explicit return type of Unit:  ```scaladef box(s : String): Unit = {	//...}```The concise procedure syntax can be a surprise for Java and C++ programmers. It is a common error to accidentally omit the = in a function definition. You then get an error message at the point where the function is called, and you are told that Unit is not acceptable at that location.#### Lazy ValuesWhen a val is declared as __lazy__, its initialization is deferred until it is accessed for the first time. For example,  ```scalalazy val words = scala.io.Source.fromFile("/usr/share/dict/words").mkString```Lazy values are useful to delay costly initialization statements. They can also deal with other initialization issues, such as circular dependencies. Moreover, `they are essential for developing lazy data structures—see Section 13.13, “Streams”`You can think of lazy values as halfway between val and def. Compare  ```scalaval words = scala.io.Source.fromFile("/usr/share/dict/words").mkString// Evaluated as soon as words is definedlazy val words = scala.io.Source.fromFile("/usr/share/dict/words").mkString// Evaluated the first time words is useddef words = scala.io.Source.fromFile("/usr/share/dict/words").mkString// Evaluated every time words is used````Laziness is not cost-free. Every time a lazy value is accessed, a method is called that checks, in a threadsafe manner, whether the value has already been initialized.`#### ExceptionsScala exceptions work the same way as in Java or C++.  As in Java, the objects that you throw need to belong to a subclass of java.lang.Throwable. However, unlike Java, Scala has `no “checked” exceptions`—you never have to declare that a function or method might throw an exception.`A throw expression has the special type Nothing. That is useful in if/else expressions. If one branch has type Nothing, the type of the if/else expression is the type of the other branch.`   For example, consider  ```scalaif (x >= 0) {      sqrt(x)} else throw new IllegalArgumentException("x should not be negative")```The first branch has type Double, the second has type `Nothing`. Therefore, the if/else expression also has type Double.The syntax for catching exceptions is modeled after the pattern matching syntax (see Chapter 14).```scala    var io:InputStream = null    try{          io = new URL("http://horstmann.com/fred-tiny.gif").openStream()    }catch{      case _: MalformedURLException => println("Bad URL: " + io.toString())      case ex: FileNotFoundException => ex.printStackTrace()      case ex: IOException => ex.printStackTrace()    }finally{      if ( io != null ){        io.close      }    } ```As in Java or C++, the more general exception types should come after the more specific ones.Note that you can use _ for the variable name if you don’t need it.The try/finally statement lets you dispose of a resource whether or not an exception has occurred. For example:```scala    var in = new URL("http://horstmann.com/fred.gif").openStream()    try {      process(in)    } finally {      in.close()    }```The finally clause is executed whether or not the process function throws an exception. The reader is always closed.  It is possible to combine them into a single try/catch/finally statement:try { ... } catch { ... } finally { ... }Working with Arrays---* Use an **Array** if the length is fixed, and an **ArrayBuffer** if the length can vary.  * Don’t use new when supplying initial values.  * Use () to access elements.  * Use for (elem <- arr) to traverse the elements.  * `Use for (elem <- arr if . . . ) . . . yield . . . to transform into a new array`  * Scala and Java arrays are interoperable; with ArrayBuffer, use **scala.collection.JavaConversions**.```scala// A string array with ten elements, all initialized with nullval a = new Array[String](10)val s = Array("Hello", "World")s(0) = "Goodbye"// Array("Goodbye", "World")````Inside the JVM, a Scala Array is implemented as a Java array.````scalaimport scala.collection.mutable.ArrayBufferval b = ArrayBuffer[Int]()// Or new ArrayBuffer[Int]// Or new ArrayBuffer[Int]()// An empty array buffer, ready to hold integersb += 1// ArrayBuffer(1)// Add an element at the end with +=b += (1, 2, 3, 5)// ArrayBuffer(1, 1, 2, 3, 5)// Add multiple elements at the end by enclosing them in parenthesesb ++= Array(8, 13, 21)// ArrayBuffer(1, 1, 2, 3, 5, 8, 13, 21)b ++= 22 to 23// ArrayBuffer(1, 1, 2, 3, 5, 8, 13, 21, 22, 23)// You can append any collection with the ++= operator//    b += 4 to 10        // failed due to type mismatch//    b += Array(11, 12)  // failed due to type mismatchb.trimEnd(5)// ArrayBuffer(1, 1, 2, 3, 5)// Removes the last five elements```Adding or removing elements at the end of an array buffer is an efficient (“amortized constant time”) operation. You can also insert and remove elements at an arbitrary location, but those operations are not as efficient—all elements after that location must be shifted.  ```scalaval b = ArrayBuffer(1, 1, 2, 3, 5)b.insert(2, 10, 11, 12)// ArrayBuffer(1, 1, 10, 11, 12, 2, 3, 5)b.remove(2)// ArrayBuffer(1, 1, 11, 12, 2, 3, 5)b.remove(2, 2)// ArrayBuffer(1, 1, 2, 3, 5)```Sometimes, you want to build up an Array, but you don’t yet know how many elements you will need. In that case, first make anarray buffer, then call  **b.toArray**  Conversely, call **a.toBuffer** to convert the array a to an array buffer.It is very easy to take an array (or array buffer) and transform it in some way. Such transformations `don’t modify the original array, but they yield a new one.`#### Range```scalaprintln(1 to 10)            // Range(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)println(1 until 10)         // Range(1, 2, 3, 4, 5, 6, 7, 8, 9)println((1 to 10).reverse)  // Range(10, 9, 8, 7, 6, 5, 4, 3, 2, 1)// every second elementprintln( 1 to (10, 2) )     // Range(1, 3, 5, 7, 9)```#### for if yield or filter mapOftentimes, when you traverse a collection, you only want to process the elements that match a particular condition. This is achieved with a guard: an if inside the for. Here we double every even element, dropping the odd ones:  ```scalafor (elem <- a if elem % 2 == 0) yield 2 * elem```Alternatively, you could write```scalaa.filter(_ % 2 == 0).map(2 * _)a filter { _ % 2 == 0 } map { 2 * _ }a filter(_ % 2 == 0) map(2 * _)b.filter { _ % 2 == 0 }.map { 2 * _ }```Some programmers with experience in functional programming prefer filter and map to guards and yield. That’s just a matter of style—the for loop does exactly the same work. Use whichever you find easier.  `Keep in mind that the result is a new collection—the original collection is not affected`.```scala  val input = ArrayBuffer(1, 2, 3, 4, 5, 6)// there is no ++ operator in scala var latch = new AtomicInteger(-1);val res4 = for ( i <- input if latch.incrementAndGet() > 0 ) yield iprintln(res4)  // ArrayBuffer(2, 3, 4, 5, 6)```An example, Given an array buffer of integers, we want to remove all but the first negative number.  ```scala// efficient oneval dataset = ArrayBuffer(1, 2, -3, 4, -5, 6, 7, -9 )println("input array:" + dataset)var first = trueval indexSet = for ( i <- 0 until dataset.length if first || dataset(i) >= 0) yield {  if ( dataset(i) < 0 ) first = false ; i     }for ( i <- 0 until indexSet.length ) {  dataset(i) = dataset(indexSet(i))}dataset.trimEnd(dataset.length - indexSet.length)println(dataset)// inefficient oneprintln("removeAllButFirstNegativeInefficient")val dataset = ArrayBuffer(1, 2, -3, 4, -5, 6, 7, -9 )println("input array:" + dataset)var first = truevar i = 0while (i < dataset.length){  if ( dataset(i) < 0 ){    if ( first ){      first = false; i += 1    }else{      dataset.remove(i);    }  }else {    i += 1  }}println("result:\t" + dataset)``````scalaval a5 = Array(1, 7, 2, 9)println(a5.sum)                // 19println(a5.mkString(" | "))    // 1 | 7 | 2 | 9println(a5)                    // some value like [I@16f7412```#### array sorting```scalavar a1 = ArrayBuffer(1, 3,  1, 2, 8, 5)val aRes = a1.sortBy(x => -x)val aRes2 = a1.sortWith(_ > _)println(aRes)        // ArrayBuffer(8, 5, 3, 2, 1, 1)println(aRes2)       // ArrayBuffer(8, 5, 3, 2, 1, 1)````You can sort an array, but not an array buffer, in place`:  ```scalaval a = Array(1, 7, 2, 9)scala.util.Sorting.quickSort(a)// a is now Array(1, 2, 7, 9)```For the min, max, and quickSort methods, the element type must have a comparison operation. This is the case for numbersstrings, and other types with the __Ordered trait__.#### multidimensional arraysLike in Java, multidimensional arrays are implemented as arrays of arrays. For example, a two-Dimensional array of Double values has the type Array[Array[Double]]. To construct such an array, use the ofDim method:```scalaval matrix = Array.ofDim[Int](3,4) // Three rows, four columnsval raggerArray = new Array[Array[Int]](5)for (i <- 0 until raggerArray.length ){  raggerArray(i) = new Array[Int](i+2)      }```To access an element, use two pairs of parentheses:  `matrix(row)(column) = 42`####  Interoperating with JavaSince Scala arrays are implemented as Java arrays, you can pass them back and forth between Java and Scala.  If you call a Java method that receives or returns a java.util.List, you could, of course, use a Java ArrayList in your Scala code— but that is unattractive. Instead, import the implicit conversion methods in scala.collection.JavaConversions. Then you can use Scala buffers in your code, and they automatically get wrapped into Java lists when calling a Java method.```scalaimport scala.collection.JavaConversions.bufferAsJavaList import scala.collection.mutable.ArrayBufferval command = ArrayBuffer("ls", "-al", "/home/cay")val pb = new ProcessBuilder(command) // Scala to Java                                     // java.lang.ProcessBuilder, plain java class, one of constructor takes java.util.List as parameter```The Scala buffer is wrapped into an object of a Java class that implements the java.util.List interface.Conversely, when a Java method returns a java.util.List, you can have it automatically converted into a Buffer:```scalaimport scala.collection.JavaConversions.asScalaBuffer import scala.collection.mutable.Bufferval cmd : Buffer[String] = pb.command() // Java to Scala// You can't use ArrayBuffer—the wrapped object is only guaranteed to be a Buffer``````scalaval command = ArrayBuffer("ls", "-al", "/home/cay")val pb = new ProcessBuilder(command)val cmd: Buffer[String] = pb.command()println(cmd)      // ArrayBuffer(ls, -al, /home/cay)```Maps and Tuples---* Scala has a pleasant syntax for creating, querying, and traversing maps.   * You need to choose between mutable and immutable maps.  * `By default, you get a hash map, but you can also get a tree map`.* You can easily convert between Scala and Java maps. * **Tuples** are useful for aggregating values.Scala has a general notion of **tuples**—aggregates of n objects, not necessarily of the same type. A **pair** is simply a tuple with n = 2.You can construct a map as  ```scalaval scores = Map("Alice" -> 10, "Bob" -> 3, "Cindy" -> 8)```This constructs an immutable Map[String, Int] whose contents can’t be changed. If you want a mutable map, use  ```scalaval scores = scala.collection.mutable.Map("Alice" -> 10, "Bob" -> 3, "Cindy" -> 8)```If you want to start out with a blank map, you have to supply type parameters:  ```scalaval scores = new scala.collection.mutable.HashMap[String, Int]```#### pairIn Scala, `a map is a collection of pairs`. A **pair** is simply a grouping of two values, not necessarily of the same type, such as ("Alice", 10).The `-> operator` makes a pair.  ```scala "Alice" -> 10  res1: (String, Int) = (Alice,10)  //PS: it is not a Range```You could have equally well defined the map as  ```scalaval scores = Map(("Alice", 10), ("Bob", 3), ("Cindy", 8))``````scalaval scores_im = Map("Alice" -> 10, "Bob" -> 3, "Cindy" -> 8)val scores1 = new scala.collection.mutable.HashMap[String, Int]val scores2 = scala.collection.mutable.Map("Alice" -> 10, "Bob" -> 3, "Cindy" -> 8)val scores3 = Map(("Alice", 10), ("Bob", 3), ("Cindy", 8))````In Scala, the analogy between functions and maps is particularly close because you use the () notation to look up key values.`  ```scalaval bobsScore = scores("Bob") // Like scores.get("Bob") in Java````If the map doesn’t contain a value for the requested key, an exception is thrown.````scalaval bobsScore = if (scores.contains("Bob")) scores("Bob") else 0```Since this call combination is so common, there is a shortcut:  ```scalaval bobsScore = scores.getOrElse("Bob", 0)```If the map contains the key "Bob", return the value; otherwise, return 0.  Finally, the call map.get(key) returns an **Option** object that is either Some(value for key) or None. __operate with mutable map__   ```scalaval scores2 = scala.collection.mutable.Map("Alice" -> 10, "Bob" -> 3, "Cindy" -> 8)scores2("Bob") = 30         // Updates the existing value for the key "Bob"scores2("NewGuy") = -1      // Adds a new key/value pair to scores2, "NewGuy" -> -1println(scores2)            // Map(Bob -> 30, NewGuy -> -1, Alice -> 10, Cindy -> 8)scores2 += ( "Bob" -> 15, "NewGuy2" -> 15 )println(scores)            // Map(Bob -> 15, NewGuy -> -1, Alice -> 10, NewGuy2 -> 15, Cindy -> 8)scores -= "NewGuy2"println(scores2)            // Map(Bob -> 15, NewGuy -> -1, Alice -> 10, Cindy -> 8)```__operate with immutable map__   You can’t update an immutable map, but you can do something that’s just as useful—obtain a new map that has the desired update:  ```scalaval newScores = scores + ("Bob" -> 10, "Fred" -> 7) // New map with update```The newScores map contains the same associations as scores, except that "Bob" has been updated and "Fred" added.Instead of saving the result as a new value, you can update a var:  ```scalavar scores = ...scores = scores + ("Bob" -> 10, "Fred" -> 7)```Similarly, to remove a key from an immutable map, `use the - operator to obtain a new map without the key`:  ```scalascores = scores - "Alice"```You might think that it is inefficient to keep constructing new maps, but that is not the case. `The old and new maps share most of their structure.` (This is possible because they are immutable.)The following amazingly simple loop iterates over all key/value pairs of a map:  ```scalafor ((k, v) <- map ) process k and v```For example:  ```scalaval scores = Map(Bob -> 15, NewGuy -> -1, Alice -> 10, Cindy -> 8)for ( (k,v) <- scores ){  println(k + "->" + v)}println(scores.keySet)    // Set(Bob, NewGuy, Alice, Cindy)for( v <- scores.values ) {  println(v)}// To get an immutable tree map instead of a hash mapval scoresSorted = scala.collection.immutable.SortedMap("Alice" -> 10, "Fred" -> 7, "Bob" -> 3, "Cindy" -> 8)val inversedScores = for( (k, v) <- scores ) yield (v,k)println(inversedScores)   // Map(8 -> Cindy, -1 -> NewGuy, 10 -> Alice, 15 -> Bob)````When working with a map, you need to choose an implementation—a hash table or a balanced tree. By default, Scala gives you a hash table.` You might want a tree map if you don’t have a good hash function for the keys, or if you need to visit the keys in sorted order.`Unfortunately, there is (as of Scala 2.9) no mutable tree map. Your best bet is to adapt a Java TreeMap,`If you want to visit the keys in insertion order, use a LinkedHashMap.  ```scalaval months = scala.collection.mutable.LinkedHashMap("January" -> 1, "February" -> 2, "March" -> 3, "April" -> 4,"May" -> 5)```#### Interoperating with Java for mapIf you get a Java map from calling a Java method, you may want to convert it to a Scala map so that you can use the pleasant Scala map API. This is also useful if you want to work with a mutable tree map, which Scala doesn’t Provide.```scalaimport scala.collection.JavaConversions.mapAsScalaMapimport scala.collection.JavaConversions.propertiesAsScalaMapimport scala.collection.JavaConversions.mapAsJavaMapimport java.awt.font.TextAttribute._val scores1: scala.collection.mutable.Map[String, Int] = new java.util.TreeMap[String, Int];val scores2: scala.collection.mutable.Map[String, String] = System.getPropertiesval attr = Map(FAMILY -> "Serif", SIZE -> 12)val font = new java.awt.Font(attr)```#### Tuples```scalaval tup1 = (1, 3.14, "Fred")println(tup1)println(tup1._2)println(tup1 _3)var (first, _, third) = tup1 println(first)println("New York".partition { x => x.isUpper })val res = "New York".partition(_.isUpper)println(res)    // Yields the pair ("NY", "ew ork")```#### Tuples to MapThe toMap method turns a collection of pairs into a map.  If you have a collection of keys and a parallel collection of values, then zip them up and turn them into a map like this:  ```scalakeys.zip(values).toMap``````scalaval symbols = Array("<", "-", ">") val counts = Array(2, 10, 3)val pairs = symbols.zip(counts)// yields an array of pairs Array(("<", 2), ("-", 10), (">", 3))for ( pair  <- pairs ){  println(pair)}println(pairs.toMap)    // Map(< -> 2, - -> 10, > -> 3)```Classes---* `Fields in classes automatically come with getters and setters`.  * You can replace a field with a custom getter/setter without changing the client of a class—that is the “uniform access principle.”  * Use the @BeanProperty annotation to generate the JavaBeans getXxx/setXxx methods.  * Every class has a **primary constructor** that is “interwoven” with the class definition. Its parameters turn into the fields of the class. The primary constructor executes all statements in the body of the class.  * Auxiliary constructors are optional. They are called this.`Methods are public by default`In Scala, a class is not declared as public. A Scala source file can contain multiple classes, and all of them have public visibility.```scalaclass Counter {  private var value = 0 // You must initialize the field  def increment() { value += 1 } // Methods are public by default  def current() = value  def enforcedCurrent = value}val myCounter = new Counter // Or new Counter()myCounter.increment()println(myCounter.current)  // or myCounter.current()println(myCounter.enforcedCurrent)  // can't use myCounter.enforcedCurrent()```It is considered good style to use () for a mutator method (a method that changes the object state), and to drop the () for an accessor method (a method that does not change the object state).Scala provides getter and setter methods for every field. Here, we define a public field:  ```scalaclass Person {     var age=0}```Scala generates a class for the JVM with a private age field and getter and setter methods. These methods are **public** becausewe did not declare age as private. (`For a private field, the getter and setter methods are private.`) In Scala, the getter and setter methods are called `age` and `age_=`.   For example,  ```scalaprintln(fred.age) // Calls the method fred.age() fred.age = 21 // Calls fred.age_=(21)```To see these methods with your own eyes, compile the Person class and then look at the bytecode with **javap**:  ```shell$ scalac Person.scala$ javap -private Person``````scalaCompiled from "Person.scala"public class Person extends java.lang.Object implements scala.ScalaObject{  private int age;  public int age();  public void age_$eq(int);  public Person();}```The = symbol is translated to $eq because the JVM does not allow an = in a method name.You can create a new property  ```scalaclass Person {  private var privateAge = 0 // Make private and rename  def age = privateAge  def age_=(newValue: Int) {    if (newValue > privateAge) privateAge = newValue; // Can't get younger  }}val fred = new Personfred.age = 30println(fred.age) // 30```Sometimes you want a read-only property with a getter but no setter. If the value of the property never changes after the object has been constructed, use a val field:```scalaclass Message {  val timeStamp = new java.util.Date  ...}```Scala makes `a private final field` and a getter method, but no setter.To summarize, you have four choices for implementing properties:1. var foo: Scala synthesizes a getter and a setter. 2. val foo: Scala synthesizes a getter.3. You define methods foo and foo_=.4. You define a method foo.In Scala, you cannot have a write-only property (that is, a property with a setter and no getter).  It may sound scary that Scala generates getter and setter methods for every field. But you have some control over this process.  1. If the field is private, the getter and setter are private.  2. If the field is a val, only a getter is generated.  3. If you don’t want any getter or setter, declare the field as **private[this]**#### Object-Private FieldsIn Scala (as well as in Java or C++), a method can access the private fields of all objects of its class.   ```scalaclass Counter {  private var value = 0  def increment() { value += 1 }  def isLess(other : Counter) = value < other.value  // Can access private field of other object}```Scala allows an even more severe access restriction, with the **private[this]** qualifier:   ```scalaclass Counter {  private[this] var value = 0 // Accessing someObject.value is not allowed}```Now, the methods of the Counter class can only access the value field of the current object, not of other objects of type Counter.With a class-private field, Scala generates private getter and setter methods. However, `for an object-private field, no getters and setters are generated at all.`Scala allows you to grant access rights to specific classes. The **private[ClassName]** qualifier states that only methods of the given class can access the given field. Here, the ClassName must be the name of the class being defined or an enclosing class.When you annotate a Scala field with `@BeanProperty`, then such methods are automatically generated. For example,  ```scalaimport scala.reflect.BeanPropertyclass Person {  @BeanProperty var name: String = _}```generates four methods:  1. name: String2. name_=(newValue: String): Unit3. getName(): String4. setName(newValue: String): UnitIf you define a field as a primary constructor parameter and you want JavaBeans getters and setters, annotate the constructor parameter like this:```scalaclass Person(@BeanProperty var name: String)```A Scala class has one constructor that is more important than all the others, called the primary constructor. In addition, a class may have any number of auxiliary constructors.#### auxiliary constructorAuxiliary constructors are very similar to constructors in Java or C++, with just two differences.  1. The auxiliary constructors are called `this`. (In Java or C++, constructors have the same name as the class—which is not so convenient if you rename the class.)2. Each auxiliary constructor must start with a call to a previously defined auxiliary constructor or the primary constructor.  ```scalaclass Person {  var name = ""  var age = 0  def this( name: String ){ // An auxiliary constructor    this()        // Calls primary constructor    this.name = name  }  def this( name: String, age : Int ){ // An auxiliary constructor    this(name)    // Calls previous auxiliary constructor    this.age = age  }}```#### primary constructorIn Scala, every class has a primary constructor. The primary constructor is not defined with a this method. Instead, it is interwoven with the class definition.If there are no parameters after the class name, then the class has a primary constructor with no parameters. That constructor simply executes all statements in the body of the class.1. The parameters of the primary constructor are placed immediately after the class name.2. `The primary constructor executes all statements in the class definition`  ```scala// class with primary constructorclass NewPerson(val name: String = "", private var age: Int = 0 ) {  println("initiating the object")}```Construction parameters can also be regular method parameters, `without val or var`. How these parameters are processed depends on their usage inside the class.  1. If a parameter without val or var is used inside at least one method, it becomes a field. For example,  ```scalaclass Person(name: String, age: Int) {  def description = name + " is " + age + " years old"}```declares and initializes immutable fields name and age that are object-private.   Such a field is the equivalent of a private[this] val field 2. Otherwise, the parameter is not saved as a field. It’s just a regular parameter that can be accessed in the code of the primary constructor. (Strictly speaking, this is an implementation-specific optimization.)When you think of the primary constructor’s parameters as class parameters, parameters without val or var become easier to understand. The scope of such a parameter is the entire class. `Therefore, you can use the parameter in methods. If you do, it is the compiler’s job to save it in a field.`Martin Odersky suggests to think about it this way: In Scala, classes takeparameters, just like methods do.You can often eliminate auxiliary constructors by using default arguments in the primary constructor. For example:```scalaclass Person(val name: String = "", val age: Int = 0)```To make the primary constructor private, place the keyword private like this:  ```scalaclass Person private(val id: Int) { ... }```A class user must then use an auxiliary constructor to construct a Person object.`In scala, inner class belongs to instance of outer class`, this is different from Java, where an inner class belongs to the outer class.(only for static inner class??)The Scala approach is more regular. For example, to make a new inner object, you simply use new with the type name:  new chatter.Member. In Java, you need to use a special syntax, chatter.new Member().Tow ways to resolve,  1. move inner class to outer class's companion object  2. to use a type projection OuterClass#InnerClass, which means “a InnerClass of any OuterClass.”In a nested class, you can access the this reference of the enclosing class as **EnclosingClass.this**, like in Java. Objects---In this short chapter, you will learn when to use the object construct in Scala. `Use it when you need a class with a single instance, or when you want to find a home for miscellaneous values or functions.`    The key points of this chapter are:    * Use objects for singletons and utility methods.  * A class can have a companion object with the same name.  * Objects can extend classes or traits.  * The apply method of an object is usually used for constructing new instances of the companion class.   * To avoid the main method, use an object that extends the **App** trait.  * You can implement enumerations by extending the Enumeration object.  `Scala has no static methods or fields. Instead, you use the object construct.`An object defines a single instance of a class with the features that you want.```scalaobject Accounts {  private var lastNumber = 0  def newUniqueNumber() = { lastNumber += 1; lastNumber }}```The constructor of an object is executed when the object is first used.In our example, the Accounts constructor is executed with the first call to Accounts.newUniqueNumber().`An object can have essentially all the features of a class`—it can even extend other classes or traits (see Section 6.3, “Objects Extending a Class or Trait,” on page 67). There is just one exception: You cannot provide constructor parameters.#### Companion ObjectsIn Java or C++, you often have a class with both instance methods and static methods. In Scala, you achieve this by having a class and a “companion” object of the same name. ```scalaclass Account {  var id = Account.newUniqueNumber()  private var balance = 0.0  def deposit(amount : Double) {    balance += amount  }}// companion objectobject Account{  private var lastNumber = 0  def newUniqueNumber () = { lastNumber += 1; lastNumber }}```The class and its companion object can access each other’s private features.   They must be located in the same source file.  The companion object of a class is accessible, but it is not in scope. For example, the Account class has to call Account.newUniqueNumber() and not just newUniqueNumber() to invoke the method of the companion object.__Objects Extending a Class or Trait__  An object can extend a class and/or one or more traits. The result is an object of a class that extends the given class and/or traits, and in addition has all of the features specified in the object definition.```scala```###The apply Method 1It is common to have objects with an apply method. The apply method is called for expressions of the form Object(arg1, ..., argN)  Typically, such an apply method returns an object of the companion class.Why doesn’t one just use a constructor? Not having the new keyword is handy for nested expressions, such as  ```scala  Array(Array(1, 7), Array(2, 9))```It is easy to confuse Array(100) and new Array(100). The first expression calls apply(100), yielding an Array[Int] with a single element, the integer 100. The second expression invokes the constructor this(100). The result is an `Array[Nothing]` with 100 null elements.#### Application Objects`Each Scala program must start with an object’s main method of type Array[String] => Unit`:  ```scalaobject Hello {  def main(args: Array[String]) {    println("hello world")  }}```Instead of providing a main method for your application, you can extend the App trait and place the program code into the constructor body:  ```scalaobject Hello extends App {    if (args.length > 0){    println("hello " + args(0))  }else{    println("hello world")  }}```If you need the command-line arguments, you can get them from the args propertyIf you invoke the application with the `scala.time` option set, then the elapsed time is displayed when the program exits.  ```shell$ scalac Hello.scala$ scala -Dscala.time Hello FredHello, Fred[total 4ms]```All this involves a bit of magic. The App trait extends another trait, **DelayedInit**, that gets special handling from the compiler. All initialization code of a class with that trait is moved into `a delayedInit method`. The main of the App trait method captures the command-line arguments, calls the delayedInit method, and optionally prints the elapsed time.Older versions of Scala had an `Application trait` for the same purpose. That trait carried out the program’s action in the `static initializer`, which is not optimized by the just-in-time compiler. Use the App trait instead.#### EnumerationsUnlike Java or C++, `Scala does not have enumerated types`. However, the standard library provides an **Enumeration** helper class that you can use to produce enumerations.  `Define an object that extends the Enumeration class` and initialize each value in your enumeration with a call to the `Value method`.  ```scalaobject TrafficLightColor extends Enumeration{  val Red, Green, Blue = Value}```Here we define three fields, Red, Green, and Blue, and` initialize each of them with a call to Value`. This is a shortcut for  ```scalaval Red = Valueval Green = Valueval Blue = Value```Each call to the Value method returns a new instance of an inner class, also called Value.  Alternatively, you can pass IDs, names, or both to the Value method:  ```scalaval Red = Value(0, "Stop")val Yellow = Value(10) // Name "Yellow"val Green = Value("Go") // ID 11```If not specified, the ID is one more than the previously assigned one, starting with zero. The default name is the field name. You can now refer to the enumeration values as TrafficLightColor.Red, TrafficLightColor.Blue, and so on. If that gets too tedious, use a statement  ```scalaimport TrafficLightColor._```if you import TrafficLightColor._, you can use expression either Red or TrafficLightColor.Red```scalaimport TrafficLightColor._println(Red)  // "Red"println(TrafficLightColor.Red)  //"Red"```Remember that the type of the enumeration is TrafficLightColor.Value and not TrafficLightColor—that’s the type of the object holding the values. Some people recommend that you add a `type alias`  ```scalaobject TrafficLightColor extends Enumeration {  type TrafficLightColor = Value  val Red, Yellow, Green = Value}```Now the type of the enumeration is TrafficLightColor.TrafficLightColor, which is only an improvement if you use an import statement.  For example,```scalaimport TrafficLightColor._def doWhat(color: TrafficLightColor) = {  if (color == Red) "stop"  else if (color == Yellow) "hurry up"  else "go"}```However, without type alias, it would be like below, that's the only difference   ```scalaimport TrafficLightColor._def doWhat(color: TrafficLightColor.Value) = {  if (color == Red) "stop"  else if (color == Yellow) "hurry up"  else "go"}```The ID of an enumeration value is returned by the id method, and its name by the toString method.  The call TrafficLightColor.values yields a set of all values:  ```scalafor (c <- TrafficLightColor.values) println(c.id + ": " + c)```Finally, you can look up an enumeration value by its ID or name. Both of the following yield the object TrafficLightColor.Red:  ```scalaTrafficLightColor(0) // Calls Enumeration.applyTrafficLightColor.withName("Red")```Packages and Imports---Both packages and imports are more regular than in Java; they are also a bit more `flexible`.The key points of this chapter are:  * `Packages nest just like inner classes`* Package paths are not absolute.  * A chain x.y.z in a package clause leaves the intermediate packages x and x.y invisible.  * Package statements without braces at the top of the file extend to the entire file.  * `A package object can hold functions and variables`. * `Import statements can import packages, classes, and objects`.  * `Import statements can be anywhere`.  * `Import statements can rename and hide members`.* java.lang, scala, and Predef are always imported.  To add items to a package, you can include them in package statements, such as:  ```scalapackage com {   package horstmann {    package impatient {       class Employee ...    }   }}```Then the class name Employee can be accessed anywhere as com.horstmann.impatient.Employee.Unlike the definition of an object or a class, `a package can be defined in multiple files.``There is no enforced relationship between the directory of the source file and the package.`  Conversely, you can contribute to more than one package in a single file.#### Scope RulesScala packages nest just like all other scopes. You can access names from the enclosing scope.`In Java, this problem can’t occur because package names are always absolute, starting at the root of the package hierarchy. But in Scala, package names are relative, just like inner class names. With inner classes`, one doesn’t usually run into problems because all the code is in one file, under control of whoever is in charge of that file. But packages are open-ended. Anyone can contribute to a package at any time.One solution is to use `absolute package names`, starting with `_root_`, for example: ```scalaval subordinates = new _root_.scala.collection.mutable.ArrayBuffer[Employee]  ```Another approach is to use **“chained” package clauses**Most programmers use complete paths for package names, without the _root_ prefix. This is safe as long as everyone avoids names scala, java, com, org, and so on, for nested packages.#### Chained Package ClausesA package clause can contain a “chain,” or path segment```scalapackage com.horstmann.impatient {  // Members of com and com.horstmann are not visible here   package people {    class Person    //...   }}```#### Top-of-File NotationInstead of the nested notation that we have used up to now, you can have package clauses at the top of the file, without braces.```scalapackage com.horstmann.impatient  package peopleclass Person //...```This is equivalent to```scalapackage com.horstmann.impatient {   package people {    class Person    // ...    // Until the end of the file  } }```#### Package ObjectsA package can contain classes, objects, and traits, but not the definitions of functions or variables. That’s an unfortunate limitation of the Java virtual machine. It would make more sense `to add utility functions or constants to a package` than to some Utils object. `Package objects address this limitation.``Every package can have one package object.` You define it in the parent package, and it has the same name as the child package. For example,  ```scalapackage com.horstmann.impatientpackage object people {  val defaultName = "John Q. Public"}package people {   class Person {    var name = defaultName // A constant from the package   }  ... }```Note that the defaultName value didn’t need to be qualified because it was in the same package. Elsewhere, it is access as `com.horstmann.impatient.people.defaultName`.Behind the scenes, the package object gets compiled into a JVM class with static methods and fields, called `package.class` In our example, that would be a class com.horstmann.impatient.people.package with a static field defaultName. (In the JVM, you can use package as a class name.)It is a good idea to use the same naming scheme for source files. Put the package object into a file `com/horstmann/impatient/people/package.scala`. That way, anyone who wants to add functions or variables to a package can find the package object easily.In Java, a class member that isn’t declared as public, private, or protected is visible in the package containing the class. In Scala, you can achieve the same effect with qualifiers. The following method is visible in its own package, or even enclosing package:  ```scalapackage com.horstmann.impatient.peopleclass Person {  private[people] def description = "A person with name " + name   ...}```You can extend the visibility to an enclosing package:  ```scalaprivate[impatient] def description = "A person with name " + name```You can import all members of a package as  ```scalaimport java.awt._```This is the same as the * wildcard in Java. In Scala, `* is a valid character for an identifier`. You could define a package com.horstmann.*.people, but please don’t.`You can also import all members of a class or object.`   ```scalaimport java.awt.Color._val c1 = RED // Color.REDval c2 = decode("#ff0000") // Color.decode```This is like import static in Java. Java programmers seem to live in fear of this variant, but in Scala it is commonly used.  Once you import a package, you can access its subpackages with shorter names. For example:  ```scalaimport java.awt._  def handler(evt: event.ActionEvent) { // java.awt.event.ActionEvent  ...}```The event package is a member of java.awt, and the import brings it into scope.In Scala, `an import statement can be anywhere`, not just at the top of a file. The scope of the import statement extends until the end of the enclosing block.This is a very useful feature, particularly with wildcard imports. It is always a bit worrisome to import lots of names from different sources. In fact, some Java programmers dislike wildcard imports so much that they never use them, but let their IDE generate long lists of imported classes.  By putting the imports where they are needed, you can greatly reduce the potential for conflicts.#### Renaming and Hiding MembersIf you want to import a few members from a package, use a selector like this:  ```scalaimport java.awt.{Color, Font}```The selector syntax lets you rename members:  ```scalaimport java.util.{HashMap => JavaHashMap}import scala.collection.mutable._```Now JavaHashMap is a java.util.HashMap and plain HashMap is a scala.collection. mutable.HashMap.  The selector `=> _` hides a member instead of renaming it. This is only useful if you import others:  ```scalaimport java.util.{HashMap => _, _}import scala.collection.mutable._```Now HashMap unambiguously refers to scala.collection.mutable.HashMap since java.util.HashMap is hidden.Every Scala program implicitly starts with  import java.lang._  import scala._  import Predef._  Next, the scala package is imported, but in a special way. Unlike all otherimports, this one is allowed to override the preceding import. For example, scala.StringBuilder overrides java.lang.StringBuilder instead of conflicting with it.Inheritance---* The extends and final keywords are as in Java.* You must use override when you override a method.* Only the primary constructor can call the primary superclass constructor.* `You can override fields`.You can also declare individual methods or `fields` final so that they cannot be overridden. Note that this is different from Java, where a final field is immutable, similar to val in Scala.In Scala, you must use the override modifier when you override a method that isn’t abstract.#### Type Checks and CastsTo test whether an object belongs to a given class, use the `isInstanceOf` method. If the test succeeds, you can use the `asInstanceOf` method to convert a reference to a subclass reference:  ```scalaif (p.isInstanceOf[Employee]) {  val s = p.asInstanceOf[Employee] // s has type Employee  ...}```The p.isInstanceOf[Employee] test succeeds if p refers to an object of class Employee or its subclass (such as Manager).  `If p is null, then p.isInstanceOf[Employee] returns false and p.asInstanceOf[Employee] returns null.`  `If p is not an Employee, then p.asInstanceOf[Employee] throws an exception`.   PS: subclass.isInstanceOf[parentClass]  returns true   If you want to test whether p refers to an Employee object, but not a subclass, use  ```scalaif (p.getClass == classOf[Employee])```The classOf method is defined in the scala.Predef object that is always imported.However, pattern matching is usually a better alternative to using type checks and casts.(PS: its implementation is like isInstanceOf) For example,  ```scalaval child = new Childchild match {  case p: Parent => println("enter parent branch"); p.doSomething    // Process p as an Parent  case c: Child => println("enter child branch"); c.doSomething  case _ => // child wasn't an Employee}// prints: "enter parent branch"```As in Java or C++, you can declare a field or method as protected. Such a member is accessible from any subclass, but not from other locations.  `Unlike in Java, a protected member is not visible throughout the package to which the class belongs.`  There is also a protected[this] variant that restricts access to the current object, similar to the private[this] variantThe auxiliary constructors of the subclass eventually call the primary constructor of the subclass. Only the primary constructor can call a superclass constructor.  As a consequence, an auxiliary constructor can never invoke a superclass constructor directly.In a Scala constructor, you can never call super(params), as you would in Java, to call the superclass constructor.This defines a subclass and a primary constructor that calls the superclass constructor  ```scalaclass Employee(name: String, age: Int, val salary : Double) extendsPerson(name, age)class Person( name: String, age: Int )```A Scala class can extend a Java class. Its primary constructor must invoke one of the constructors of the Java superclass. For example,  ```scalaclass Square(x: Int, y: Int, width: Int) extends java.awt.Rectangle(x, y, width, width)```#### Overriding Fields1. A def can only override another def.2. A val can only override another val or a parameterless def.3. A var can only override an abstract var```scalaclass Person(val name: String) {  override def toString = getClass.getName + "[name=" + name + "]"}class SecretAgent(codename: String) extends Person(codename) {  override val name = "secret" // Don't want to reveal name . . .  override val toString = "secret" // . . . or class name}```A more common case is to override an abstract def with a val, like this:  ```scalaabstract class Person { // See Section 8.8 for abstract classes  def id: Int // Each person has an ID that is computed in some way  ...}class Student(override val id: Int) extends Person  // A student ID is simply provided in the constructor```#### Anonymous SubclassesAs in Java, you make an instance of an anonymous subclass if you include a block with definitions or overrides, such as  ```scalaval alien = new Person("Fred") {  def greeting = "Greetings, Earthling! My name is Fred."}```Technically, this creates an object of a structural type—see Chapter 18 for details. The type is denoted as Person{def greeting:String}. You can use this type as a parameter type:  ```scaladef meet(p: Person{def greeting: String}) {  println(p.name + " says: " + p.greeting)}```#### Abstract FieldsIn addition to abstract methods, a class can also have abstract fields. An abstract field is simply a field without an initial value. For example,  ```scalaabstract class Person {  val id: Int  // No initializer—this is an abstract field with an abstract getter method  var name: String  // Another abstract field, with abstract getter and setter methods}```This class defines abstract getter methods for the id and name fields, and an abstract setter for the name field. The generated Java class has no fields.Concrete subclasses must provide concrete fields, for example:  ```scalaclass Employee(val id: Int) extends Person { // Subclass has concrete id propertyvar name = "" // and concrete name property}```You can always customize an abstract field by using an anonymous type:  ```scalaval fred = new Person {  val id = 1729  var name = "Fred"}```In Java, you have a similar issue when you call a method in a superclass constructor. The method might be overridden in a subclass, and it might not do what you want it to do.You can debug construction order problems with the -Xcheckinit compiler flag. This flag generates code that throws an exception (instead of yielding the default value) when an uninitialized field is accessed.The “early definition” syntax lets you initialize val fields of a subclass before the superclass is executed. The syntax is so ugly that only a mother could love it. You place the val fields in a block after the extends keyword, like this:  ```scalaclass Bug extends {  override val range = 2} with Creatureclass Creature {  val range: Int = 10  val env: Array[Int] = new Array[Int](range)}class Ant extends Creature {  override val range = 2}```#### The Scala Inheritance Hierarchy![scala_inheritance_hierarchy_1]  Figure 8–1 shows the inheritance hierarchy of Scala classes. The classes that correspond to the primitive types in Java, as well as the type Unit, extend AnyVal.  All other classes are subclasses of the AnyRef class, which is a synonym for the Object class from the Java or .NET virtual machine.  Both AnyVal and AnyRef extend the Any class, the root of the hierarchy.  The Any class defines methods isInstanceOf, asInstanceOf, and the methods for equality and hash codes that we will look at in Section 8.12, “Object Equality,” on page 95.  AnyVal does not add any methods. It is just a marker for value types.  The AnyRef class adds the monitor methods wait and notify/notifyAll from the Object class. It also provides a synchronized method with a function parameter. That method is the equivalent of a synchronized block in Java. For example,  ```scalaaccount.synchronized { account.balance += amount }```All Scala classes implement the marker interface ScalaObject, which has no methods.  At the other end of the hierarchy are the Nothing and Null types.  Null is the type whose sole instance is the value null. You can assign null to any reference, but not to one of the value types.   The Nothing type has no instances. It is occasionally useful for generic constructs. For example, the empty list Nil has type List[Nothing], which is a subtype of List[T] for any T.The Nothing type is not at all the same as void in Java or C++. In Scala, void is represented by the Unit type, the type with the sole value (). Note that Unit is not a supertype of any other type. However, the compiler still allows any value to be replaced by a (). Consider  ```scaladef printAny(x: Any) { println(x) }def printUnit(x: Unit) { println(x) }printAny("Hello") // Prints HelloprintUnit("Hello")// Replaces "Hello" with () and calls printUnit(()), which prints () at last```In Scala, the eq method of the AnyRef class checks whether two references refer to the same object. The equals method in AnyRef calls eq. When you implement a class, you should consider overriding the equals method to provide a natural notion of equality for your situation.  Be sure to define the equals method with parameter type Any.   ```scalafinal def equals(other: Any) = { ... }```Files and Regular Expressions---* Source.fromFile(...).getLines.toArray yields all lines of a file.* Source.fromFile(...).mkString yields the file contents as a string.* To convert a string into a number, use the toInt or toDouble method.* Use the Java PrintWriter to write text files.* "regex".r is a Regex object.* Use """...""" if your regular expression contains backslashes or quotes.* If a regex pattern has groups, you can extract their contents using the syntax for (regex(var1, ...,varn) <- string).To read all lines from a file, call the getLines method on a scala.io.Source object:  ```scalaimport scala.io.Sourceval source = Source.fromFile("myfile.txt", "UTF-8")val lineIterator = source.getLinesfor (l <- lineIterator) process lval lines1: Array = source.getLines.toArrayval lines: ArrayBuffer = source.getLines.toBufferval contents = source.mkString```Call close when you are done using the Source object.```scalafor (c <- source) process c     // processing charval tokens = source.mkString.split("\\s+")val source1 = Source.fromURL("http://horstmann.com", "UTF-8")val source2 = Source.fromString("Hello, World!")// Reads from the given string—useful for debuggingval source3 = Source.stdin// Reads from standard input```If you want to be able to peek at a character without consuming it (like istream::peek in C++ or a PushbackInputStreamReader in Java), call the buffered method on the source object. Then you can peek at the next input character with the head method without consuming it.```scalaval source = Source.fromFile("myfile.txt", "UTF-8")val iter = source.bufferedwhile (iter.hasNext) {  if (iter.head is nice)  process iter.next  else  ...} source.close()```Remember—you can always use the java.util.Scanner class to process a file that contains a mixture of text and numbers.Scala has no provision for reading binary files. You’ll need to use the Java library. Here is how you can read a file into a byte array:  ```scalaval file = new File(filename)val in = new FileInputStream(file)val bytes = new Array[Byte](file.length.toInt)in.read(bytes)in.close()```Scala has no built-in support for writing files. To write a text file, use a java.io.PrintWriter, for example:  ```scalaval out = new PrintWriter("numbers.txt")for (i <- 1 to 100) out.println(i)out.close()```The Serializable trait is defined in the scala package and does not require an import.```scala@SerialVersionUID(42L) class Person extends Serializable```The Scala collections are serializable, so you can have them as members of your serializable classes#### Process ControlScala was designed to scale from humble scripting tasks to massive programs. The scala.sys.process package provides utilities to interact with shell programs. You can write your shell scripts in Scala, with all the power that the Scala language puts at your disposal.  Here is a simple example:  ```scalaimport sys.process._"ls -al .." !```As a result, the ls -al .. command is executed, showing all files in the parent directory. The result is printed to standard output.The sys.process package contains an implicit conversion from strings to ProcessBuilder objects. The ! operator executes the ProcessBuilder object.The result of the ! operator is the exit code of the executed program: 0 if the program was successful, or a nonzero failure indicator otherwise.If you use !! instead of !, the output is returned as a string:  ```scalaval result = "ls -al .." !!```The process library uses the familiar shell operators | > >> < && ||, but it prefixes them with a # so that they all have the same precedence.You can pipe the output of one program into the input of another, using the #| operator:  ```scala"ls -al .." #| "grep sec" !``````scala// To redirect the output to a file, use the #> operator:"ls -al .." #> new File("output.txt") !// To append to a file, use #>> instead:"ls -al .." #>> new File("output.txt") !// To redirect input from a file, use #<:"grep sec" #< new File("output.txt") !// You can also redirect input from a URL:"grep Scala" #< new URL("http://horstmann.com/index.html") !```You can combine processes with p #&& q (execute q if p was successful) and p #|| q (execute q if p was unsuccessful). But frankly, Scala is better at control flow than the shell, so why not implement the control flow in Scala?If you need to run a process in a different directory, or with different environment variables, construct a ProcessBuilder with the apply method of the Process object. Supply the command, the starting directory, and a sequence of (name, value) pairs for environment settings:  ```scalaval p = Process(cmd, new File(dirName), ("LANG", "en_US"))```Then execute it with the ! operator:  "echo 42" #| p !#### Regular ExpressionsWhen you process input, you often want to use regular expressions to analyze it. The scala.util.matching.Regex class makes this simple. To construct a Regex object, use the r method of the String class:  ```scalaval numPattern = "[0-9]+".r```If the regular expression contains backslashes or quotation marks, then it is a good idea to use the “raw” string syntax, """...""". For example:  ```scalaval wsnumwsPattern = """\s+[0-9]+\s+""".r// A bit easier to read than "\\s+[0-9]+\\s+".r```The findAllIn method returns an iterator through all matches. You can use it in a for loop:  ```scalafor (matchString <- numPattern.findAllIn("99 bottles, 98 bottles"))process matchString```The findAllIn method returns an iterator through all matches. You can use it in a for loop:  ```scalafor (matchString <- numPattern.findAllIn("99 bottles, 98 bottles"))process matchString// or turn the iterator into an array:val matches = numPattern.findAllIn("99 bottles, 98 bottles").toArray// Array(99, 98)```Groups are useful to get subexpressions of regular expressions. Add parentheses around the subexpressions that you want to extract, for example:```scalaval numitemPattern = "([0-9]+) ([a-z]+)".r```To match the groups, use the regular expression object as an “extractor” (see Chapter 14), like this:  ```scalaval numitemPattern(num, item) = "99 bottles"// Sets num to "99", item to "bottles"```If you want to extract groups from multiple matches, use a for statement like this:  ```scalafor (numitemPattern(num, item) <- numitemPattern.findAllIn("99 bottles, 98 bottles"))process num and item```Traits---A class `implements one or more traits` in order to take advantage of the services that the traits provide. `A trait may require that implementing classes support certain features. However, unlike Java interfaces, Scala traits can supply default implementations for these features`, which makes them far more useful.  Key points of this chapter:  * `A class can implement any number of traits`.* Traits can require that implementing classes have certain fields, methods, or `superclasses`.* Unlike Java interfaces, a Scala trait can provide implementations of methods and fields.* `When you layer multiple traits, the order matters`—the trait whose methods execute first goes to the back.Scala, like Java, does not allow a class to inherit from multiple superclasses.   Some programming languages, in particular C++, allow multiple inheritance—but at a surprisingly high cost.Issues of multiple inheritance  1. Multiple inheritance works fine when you combine classes that have nothing in common. But if these classes have common methods or fields, thorny issues come up.  (In C++, you need to redefine the conflicting methods to clarify what you want.)2. diamond inheritance problem  ```scalaclass Person {  var name: String = _}class Student extends Person { ... }class Employee extends Person { ... }class TeachingAssistant extends Student, Employee { // Not actual Scala code}```We only want one name field inside a TeachingAssistant, not two. How do the fields get merged? How does the field get constructed? In C++, you use “virtual base classes,” a complex and brittle feature, to address this issue.You often want to implement some methods in terms of others, but you cannot do that in a Java interface. It is therefore common in Java to provide both an interface and an abstract base class, but that just kicks the can down the road. What if you need to extend two of those abstract base classes?Scala has traits instead of interfaces. A trait can have both abstract and concrete methods, and a class can implement multiple traits.If you need more than one trait, add the others using the with keyword:  ```scalaclass ConsoleLogger extends Logger with Cloneable with Serializable```All Java interfaces can be used as Scala traits.#### Objects with TraitsNow, nothing gets logged, which might seem pointless. But you can “mix in” a better logger when constructing an object.  ```scalatrait Logger {  def log(msg : String)}trait ConsoleLogger extends Logger {  def log (msg : String ){    println(msg)  }}trait FileLogger extends Logger {  def log (msg : String ){    println(msg)  }}abstract class SavingAccount extends Account with Logger {  def withdraw(amount: Double) {     if (amount > balance) {       log("Insufficient funds")      }else {       balance -= amount     }  }}```You can add, to a class or an object, multiple traits that invoke each other starting with the last one.  Instead, `super.log` calls the next trait in the trait hierarchy, which depends on the order in which the traits are added. Generally, traits are processed starting with the last one.  With traits, you cannot tell from the source code which method is invoked by super.someMethod. The exact method depends on the ordering of the traits in the object or class that uses them. This makes super far more flexible than in plain old inheritance.  If you need to control which trait’s method is invoked, you can specify it in brackets: `super[ConsoleLogger].log(...)`. The specified type must be an immediate supertype; you can’t access traits or classes that are further away in the inheritance hierarchy.  ```scalatrait Logger {  def log(msg : String)}trait TimestampLogger extends Logger{  abstract override def log(msg: String) {    super.log(new java.util.Date() + " " + msg)  }}trait ShortLogger extends Logger {  val maxLength = 15 // See Section 10.8 on fields in traits  abstract override def log(msg: String) {    super.log(      if (msg.length <= maxLength) msg else msg.substring(0, maxLength - 3) + "...")  }}    // print message like, "Sun Feb 06 17:45:45 ICT 2011 Insufficient...", ShortLogger is invoked at first    val acct1 = new SavingAccount with ConsoleLogger with TimestampLogger with ShortLogger    // print message like, "Sun Feb 06 1..."    val acct2 = new SavingAccount with ConsoleLogger with ShortLogger with TimestampLogger```#### Fields in TraitsA field in a trait can be concrete or abstract.   * If you supply an initial value, the field is concrete  In general, a class gets a field for each concrete field in one of its traits.These fields are not inherited; they are simply added to the subclass.  You can think of concrete trait fields as “assembly instructions” for the classes that use the trait. Any such fields become fields of the class.  * An uninitialized field in a trait is abstract and must be overridden in a concrete subclass.  ```scalatrait ShortLogger extends Logged {val maxLength: Int // An abstract field...}class SavingsAccount extends Account with ConsoleLogger with ShortLogger {val maxLength = 20 // No override necessary...}```This way of supplying values for trait parameters is particularly handy when you construct objects on the fly.   ```scalatrait ShortLogger extends Logged {val maxLength: Int // An abstract field...}class SavingsAccount extends Account with Logged { ... }val acct = new SavingsAccount with ConsoleLogger with ShortLogger {  val maxLength = 20}```The new statement constructs an instance of an anonymous class extending SavingsAccount (the superclass) with the Logged trait. #### Trait Construction OrderJust like classes, traits can have constructors, made up of field initializations and other statements in the trait’s body. Forexample,  ```scalatrait FileLogger extends Logger {  val out = new PrintWriter("app.log") // Part of the trait's constructor  out.println("# " + new Date().toString) // Also part of the constructor  def log(msg: String) { out.println(msg); out.flush() }}```Constructors execute in the following order:  * The superclass constructor is called first.* Trait constructors are executed after the superclass constructor but before the class constructor.* Traits are constructed left-to-right.* Within each trait, the parents get constructed first.* If multiple traits share a common parent, and that parent has already been constructed, it is not constructed again.* After all traits are constructed, the subclass is constructed.For example, consider this class:  ```scalaclass SavingsAccount extends Account with FileLogger with ShortLogger  ```The constructors execute in the following order:  1. Account (the superclass).2. Logger (the parent of the first trait).3. FileLogger (the first trait).4. ShortLogger (the second trait). Note that its Logger parent has already been constructed.5. SavingsAccount (the class).#### linearization of the classThe constructor ordering is the reverse of the linearization of the class. The linearization is a technical specification of all supertypes of a type. It is defined by the rule:  If C extends C1 with C2 with . . . with Cn, then lin(C) = C » lin(Cn) » . . . » lin(C2) » lin(C1)Here, » means “concatenate and remove duplicates, with the right winning out.” For example,  ```scalaclass SavingsAccount extends Account with FileLogger with ShortLogger  ```lin(SavingsAccount)  = SavingsAccount » lin(ShortLogger) » lin(FileLogger) » lin(Account)  = SavingsAccount » (ShortLogger » Logger) » (FileLogger » Logger) » lin(Account)  = SavingsAccount » ShortLogger » FileLogger » Logger » Account.  (For simplicity, I omitted the types ScalaObject, AnyRef, and Any that are at the end of any linearization.)  The linearization gives the order in which super is resolved in a trait. For example, calling super in a ShortLogger invokes the FileLogger method, and calling super in a FileLogger invokes the Logger method.#### Initializing Trait FieldsTraits cannot have constructor parameters. Every trait has a single parameterless constructor.  ```scalatrait Logger {  def log(msg : String)}trait FileLogger extends Logger {  val filename: String  val out = new PrintStream(filename)  def log(msg: String) { out.println(msg); out.flush() }}```1. early definition  ```scalaval acct = new { // Early definition block after new  val filename = "myapp.log"} with SavingsAccount with FileLogger// or in classclass SavingsAccount extends { // Early definition block after extends  val filename = "savings.log"} with Account with FileLogger {... // SavingsAccount implementation}```2. lazy value  ```scalatrait FileLogger extends Logger {  val filename: String  lazy val out = new PrintStream(filename)  def log(msg: String) { out.println(msg) } // No override needed}```However, lazy values are somewhat inefficient since they are checked for initialization before every use.Less commonly, a trait can also extend a class. That class becomes a superclass of any class mixing in the trait.   What if our class already extends another class? That’s OK, as long as it’s a subclass of the trait’s superclass.#### Self TypesWhen a trait starts out with  ```scalathis: Type =>```then it can only be mixed into a subclass of the given type.```scalatrait LoggedException extends Logged {  this: Exception =>  def log() { log(getMessage()) }}```Note that the trait does not extend the Exception class. Instead, it has a self type of Exception. That means, it can only be mixed into subclasses of Exception.There are a few situations where the self type notation is more flexible than traits with supertypes. Self types can handle circular dependencies between traits. This can happen if you have two traits that need each other.  Self types can also handle structural types—types that merely specify the methods that a class must have, without naming the class. Here is the LoggedException using a structural type:  ```scalatrait LoggedException extends Logged {  this: { def getMessage() : String } =>  def log() { log(getMessage()) }}```The trait can be mixed into any class that has a getMessage method.Scala needs to translate traits into classes and interfaces of the JVM. You are not required to know how this is done, but you may find it helpful for understanding how traits work.  1. A trait that has only abstract methods is simply turned into a Java interface. For example,  ```scalatrait Logger {  def log(msg: String)}// turns intopublic interface Logger { // Generated Java interface  void log(String msg);}```2. If a trait has concrete methods  a companion class is created whose static methods hold the code of the trait’s methods. For example,```scalatrait ConsoleLogger extends Logger {  def log(msg: String) { println(msg) }}//turns intopublic interface ConsoleLogger extends Logger { // Generated Java interface  void log(String msg);}public class ConsoleLogger$class { // Generated Java companion class  public static void log(ConsoleLogger self, String msg) {  println(msg);}```These companion classes don’t have any fields. 3. Fields in traits yield abstract getters and setters in the interface. When a class implements the trait, the fields are added to that class. For example,  ```scalatrait ShortLogger extends Logger {  val maxLength = 15 // A concrete field  ...}//is translated topublic interface ShortLogger extends Logger{  public abstract int maxLength();  public abstract void weird_prefix$maxLength_$eq(int);  ...}```The weird setter is needed to initialize the field. This happens in an initialization method of the companion class:  ```scalapublic class ShortLogger$class {  public void $init$(ShortLogger self) {    self.weird_prefix$maxLength_$eq(15)  }}```When the trait is mixed into a class, the class gets a maxLength field with a getter and setter. The constructors of that class will call the initialization method.  4. If a trait extends a superclass, the companion class does not inherit that superclass. Instead, any class implementing the trait extends the superclass.Operators---Operators are often used to build domain-specific languages—minilanguages embedded inside Scala. Implicit conversions (type conversion functions that are applied automatically) are another tool facilitating the creation of domain-specific languages.The key points of this chapter are:  * Identifiers contain either alphanumeric or operator characters.* Unary and binary operators are method calls.* Operator precedence depends on the first character, associativity on the last.* The apply and update methods are called when evaluating expr(args).* Extractors extract tuples or sequences of values from an input .As in Java, Unicode characters are allowed.  In addition, you can use any sequence of operator characters:  * ASCII characters other than letters, digits, underscore, parentheses ()[]{}, or delimiters .,;'`". In other words, any of !#%&*+-/:<=>?@\^|~.* Unicode mathematical symbols or other symbols from the Unicode categories Sm and So.Finally, you can include just about any sequence of characters in backquotes. For example,  ```scalaval `val` = 42```That example is silly, but backquotes can sometimes be an “escape hatch.” For example, in Scala, yield is a reserved word, but you may need to access a Java method of the same name. Backquotes to the rescue: Thread.`yield`().Infix operators are binary operators—they have two parameters. An operator with one parameter is called a unary operator. If it follows the argument, it is a postfix operator. The expression   ```scalaa identifier```is the same as the method call `a.identifier()`. For example,   ```scala1 toString// is the same as1.toString()```The four operators +, -, !, ~ are allowed as prefix operators, appearing before their arguments. They are converted into calls to methods with the name unary_operator. For example,    ```scala-a//means the same as a.unary_-.```associativity determines whether they are evaluated left-to-right or right-to-left. For example, in the expression 17 – 2 – 9, one computes (17 – 2) – 9. The – operator is left-associative.  In Scala, all operators are left-associative except for  * Operators that end in a colon (:)* Assignment operators  In particular, the :: operator for constructing lists is right-associative.Scala lets you extend the function call syntax  ```scalaf(arg1, arg2, ...)```to values other than functions. If f is not a function or method, then this expression is equivalent to the call  ```scalaf.apply(arg1, arg2, ...)```unless it occurs to the left of an assignment. The expression  ```scalaf(arg1, arg2, ...) = value```corresponds to the call  ```scalaf.update(arg1, arg2, ..., value)```An **extractor** is an object with an unapply method. You can think of the unapply method as being the opposite of the apply method of a companion object.An **unapply** method takes an object and extracts values from it—usually the values from which the object was constructed.  ```scalaclass Fraction(n: Int, d: Int) {  ...}object Fraction {  def apply(n: Int, d: Int) = new Fraction(n, d)  def unapply(input: Fraction) = if (input.den == 0) None else Some((input.num, input.den))}```In general, a pattern match can fail. Therefore, the unapply method returns an Option. It contains a tuple with one value for each matched variable. In our case, we return an Option[(Int, Int)].You can use unapply   * in a variable definition```scalavar Fraction(a, b) = Fraction(3, 4) * Fraction(2, 5)// a, b are initialized with the numerator and denominator of the result```* a pattern match  ```scalacase Fraction(a, b) => ... // a, b are bound to the numerator and denominatorFraction(10, 20) match {  case Fraction(a, b) => println(a + "/" + b)  case _ => println("no match") }// prints 10/20```In the preceding example, the apply and unapply methods are inverses of one another. However, that is not a requirement. You can use extractors to extract information from an object of any type.---[scala_inheritance_hierarchy_1]:/resources/img/java/scala_inheritance_hierarchy_1.png "scala_inheritance_hierarchy_1"